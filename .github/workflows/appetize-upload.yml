name: Upload APK to Appetize.io

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  upload-apk:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write
      id-token: write
    
    steps:
      - name: Log Debug Information
        run: |
          echo "::group::Environment & Permissions"
          echo "Event Name: ${{ github.event_name }}"
          echo "Ref: ${{ github.ref }}"
          echo "Actor: ${{ github.actor }}"
          echo "Repository: ${{ github.repository }}"
          echo "Workflow Permissions:"
          echo "  - contents: write"
          echo "  - pull-requests: write"
          echo "  - issues: write"
          echo "::endgroup::"
      
      - name: Checkout repository
        uses: actions/checkout@v4
      
      # Setup Java and Android build environment
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'
          cache: 'gradle'
      
      - name: Setup Gradle
        uses: gradle/actions/setup-gradle@v4
      
      - name: Grant execute permission for gradlew
        run: chmod +x gradlew 2>/dev/null || echo "No gradlew found, will use gradle command"
      
      # Build the Android APK
      - name: Build Android APK
        run: |
          echo "::group::Building Android APK"
          
          # Build debug APK (faster and doesn't require signing for Appetize.io)
          if [ -f "gradlew" ]; then
            ./gradlew assembleDebug --no-daemon --stacktrace
          else
            gradle assembleDebug --no-daemon --stacktrace
          fi
          
          echo "âœ“ APK build completed"
          echo "::endgroup::"
      
      - name: Find APK file
        id: find-apk
        run: |
          echo "::group::Searching for APK files"
          
          # Search for APK files in the build output directory
          # Priority order: debug APK (unsigned), then release APK
          APK_FILE=""
          
          # Look for debug APK first (most common for testing)
          if [ -f "app/build/outputs/apk/debug/app-debug.apk" ]; then
            APK_FILE="app/build/outputs/apk/debug/app-debug.apk"
            echo "âœ“ Found debug APK: $APK_FILE"
          # Look for release APK as fallback
          elif [ -f "app/build/outputs/apk/release/app-release.apk" ]; then
            APK_FILE="app/build/outputs/apk/release/app-release.apk"
            echo "âœ“ Found release APK: $APK_FILE"
          # Search for any APK in build outputs
          else
            APK_FILES=$(find app/build/outputs/apk -type f -name "*.apk" 2>/dev/null || true)
            if [ -n "$APK_FILES" ]; then
              APK_FILE=$(echo "$APK_FILES" | head -n 1)
              echo "âœ“ Found APK: $APK_FILE"
            fi
          fi
          
          # Verify an APK was found
          if [ -z "$APK_FILE" ]; then
            echo "âŒ ERROR: No APK file found after build"
            echo "::error::APK build succeeded but no APK file found in app/build/outputs/apk/"
            echo "Directory contents:"
            ls -R app/build/outputs/ 2>/dev/null || echo "Build outputs directory not found"
            exit 1
          fi
          
          # Get APK information
          APK_SIZE=$(wc -c < "$APK_FILE" | tr -d ' ')
          APK_NAME=$(basename "$APK_FILE")
          
          echo "APK Details:"
          echo "  Name: $APK_NAME"
          echo "  Path: $APK_FILE"
          echo "  Size: $APK_SIZE bytes"
          
          # Set output for next steps
          echo "apk_path=$APK_FILE" >> $GITHUB_OUTPUT
          echo "apk_name=$APK_NAME" >> $GITHUB_OUTPUT
          
          echo "::endgroup::"
      
      - name: Upload to Appetize.io
        id: upload
        env:
          APPETIZE_TOKEN: ${{ secrets.APPETIZE_TOKEN }}
          APK_PATH: ${{ steps.find-apk.outputs.apk_path }}
          APK_NAME: ${{ steps.find-apk.outputs.apk_name }}
        run: |
          echo "::group::Uploading APK to Appetize.io"
          
          if [ -z "$APPETIZE_TOKEN" ]; then
            echo "âŒ ERROR: APPETIZE_TOKEN secret is not set"
            echo "::error::APPETIZE_TOKEN is required. Please set it in repository secrets."
            exit 1
          fi
          
          echo "ðŸ“¤ Uploading $APK_NAME to Appetize.io..."
          
          # Upload to Appetize.io using their API
          RESPONSE=$(curl -s -w "\nHTTP_CODE:%{http_code}" \
            -X POST \
            -u "$APPETIZE_TOKEN:" \
            -F "file=@$APK_PATH" \
            -F "platform=android" \
            https://api.appetize.io/v1/apps)
          
          # Extract HTTP code and body
          HTTP_CODE=$(echo "$RESPONSE" | grep "HTTP_CODE:" | cut -d: -f2)
          BODY=$(echo "$RESPONSE" | sed '/HTTP_CODE:/d')
          
          echo "ðŸ“Š API Response (HTTP $HTTP_CODE):"
          echo "$BODY" | jq '.' 2>/dev/null || echo "$BODY"
          
          if [ "$HTTP_CODE" -eq 200 ] || [ "$HTTP_CODE" -eq 201 ]; then
            APP_URL=$(echo "$BODY" | jq -r '.publicURL // .url // empty' 2>/dev/null)
            APP_KEY=$(echo "$BODY" | jq -r '.publicKey // .key // empty' 2>/dev/null)
            
            echo "âœ… Successfully uploaded APK to Appetize.io"
            
            if [ -n "$APP_URL" ]; then
              echo "ðŸ”— App URL: $APP_URL"
              echo "app_url=$APP_URL" >> $GITHUB_OUTPUT
            fi
            
            if [ -n "$APP_KEY" ]; then
              echo "ðŸ”‘ App Key: $APP_KEY"
              echo "app_key=$APP_KEY" >> $GITHUB_OUTPUT
            fi
          else
            echo "âŒ Failed to upload APK to Appetize.io (HTTP $HTTP_CODE)"
            echo "::error::Upload failed with HTTP code $HTTP_CODE"
            exit 1
          fi
          
          echo "::endgroup::"
      
      - name: Log upload summary
        if: success()
        run: |
          echo "::group::Upload Summary"
          echo "âœ… Upload completed successfully"
          echo "ðŸ“¦ APK: ${{ steps.find-apk.outputs.apk_name }}"
          echo "ðŸ”— URL: ${{ steps.upload.outputs.app_url }}"
          echo "ðŸ”‘ Key: ${{ steps.upload.outputs.app_key }}"
          echo "::endgroup::"
      
      - name: Check FlyCI API Connectivity
        if: always()
        run: |
          echo "::group::Verifying FlyCI API connectivity"
          
          # DNS Resolution Check
          echo "ðŸ” Step 1: Checking DNS resolution for api.flyci.net..."
          if nslookup api.flyci.net > /dev/null 2>&1; then
            echo "âœ… DNS resolution successful"
            nslookup api.flyci.net
          else
            echo "âŒ ERROR: DNS resolution failed for api.flyci.net"
            echo "::error::Cannot resolve api.flyci.net. Please check network connectivity or DNS configuration."
            echo "::endgroup::"
            exit 1
          fi
          
          echo ""
          
          # HTTP Connection Check
          echo "ðŸ” Step 2: Testing HTTP connection to api.flyci.net..."
          HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" --connect-timeout 10 --max-time 30 https://api.flyci.net 2>/dev/null || echo "000")
          
          echo "HTTP Status Code: $HTTP_CODE"
          
          if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "301" ] || [ "$HTTP_CODE" = "302" ]; then
            echo "âœ… HTTP connection successful (HTTP $HTTP_CODE)"
          else
            echo "âŒ ERROR: HTTP connection failed (HTTP $HTTP_CODE)"
            echo "::error::FlyCI API at api.flyci.net is not responding with a successful HTTP status code (expected 200, 301, or 302). Received HTTP $HTTP_CODE instead."
            echo ""
            echo "Debugging information:"
            curl -v https://api.flyci.net 2>&1 | head -20 || echo "Failed to get detailed connection info"
            echo ""
            echo "Possible causes:"
            echo "  - FlyCI API service may be down"
            echo "  - Network connectivity issues"
            echo "  - Firewall blocking outbound HTTPS connections"
            echo "  - SSL/TLS certificate issues"
            echo ""
            echo "Please verify FlyCI service status or check network configuration."
            echo "::endgroup::"
            exit 1
          fi
          
          echo ""
          echo "âœ… All FlyCI API connectivity checks passed"
          echo "::endgroup::"
      
      - name: FlyCI Wingman
        if: always()
        uses: fly-ci/wingman-action@v1
